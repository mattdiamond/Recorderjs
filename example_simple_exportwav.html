<!DOCTYPE html>

<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Live input record and playback</title>
  <style type='text/css'>
    ul { list-style: none; }
    #recordingslist audio { display: block; margin-bottom: 10px; }
  </style>
</head>
<body>

  <h1>Recorder.js simple WAV export example</h1>

  <p>Works with recent versions of Chrome or Firefox, may work with opera too (not tested)</p>
  <p>Also, before you enable microphone input either plug in headphones or turn the volume down if you want to avoid ear splitting feedback!</p>

  <button onclick="startRecording(this);">record</button>
  <button onclick="stopRecording(this);" disabled>stop</button>
  
  <h2>Recordings</h2>
  <ul id="recordingslist"></ul>
  
  <h2>Log</h2>
  <pre id="log"></pre>

  <script>
  function __log(e, data) {
    log.innerHTML += "\n" + e + " " + (data || '');
  }

  var audio_context;
  var recorder;

  function startUserMedia(stream) {
    var input = audio_context.createMediaStreamSource(stream); //create an audio node.
    __log('Media stream created.');
    
    input.connect(audio_context.destination); //connects the "input" audio node to the actual sound output. If connemmented out, you can still record, but you don’t get live feedback (and thus no feedback loop and loud, pitched sound!) 
    __log('Input connected to audio context destination.');
    
    recorder = new Recorder(input); //this sets up a recorder. It does not record yet, it needs to be started via ".record()" later on
    __log('Recorder initialised.');
  }

  function startRecording(button) {
    recorder && recorder.record(); //this starts the recording of sound. Previously the recorder was created and set up with a input audio node (which in turn recieves an audio stream form our recording device)
    button.disabled = true;
    button.nextElementSibling.disabled = false;
    __log('Recording...');
  }

  function stopRecording(button) {
    recorder && recorder.stop();
    button.disabled = true;
    button.previousElementSibling.disabled = false;
    __log('Stopped recording.');
    
    // create WAV download link using audio data blob
    createDownloadLink();
    
    recorder.clear();
  }

  function createDownloadLink() {
    recorder && recorder.exportWAV(function(blob) {
      var url = URL.createObjectURL(blob);
      var li = document.createElement('li');
      var au = document.createElement('audio');
      var hf = document.createElement('a');
      
      au.controls = true;
      au.src = url;
      hf.href = url;
      hf.download = new Date().toISOString() + '.wav';
      hf.innerHTML = hf.download;
      li.appendChild(au);
      li.appendChild(hf);
      recordingslist.appendChild(li);
    });
  }

  window.onload = function init() {
    try {
      // webkit shim
      window.AudioContext = window.AudioContext || window.webkitAudioContext; //audio processing (Buffer, Gain, Delay etc.)
      navigator.getUserMedia = navigator.getUserMedia || navigator.mozGetUserMedia ||navigator.webkitGetUserMedia; //get user media provides support for accessing local recording devices (webcam, mic). Gets three parameters: 1st: mediaTypes like  {audio:true}, sucessCallback – a function that gets passed a reference to the "stream", the data that comes from the recording device, 3rd an Error-callback-function
      window.URL = window.URL || window.webkitURL; //object for creating object urls
      
      audio_context = new AudioContext;
      __log('Audio context set up.');
      __log('navigator.getUserMedia ' + (navigator.getUserMedia ? 'available.' : 'not present!'));
    } catch (e) {
      alert('No web audio support in this browser!');
    }
    
    navigator.getUserMedia({audio: true}, startUserMedia, function(e) {
      __log('No live audio input: ' + e);
    });
  };
  </script>

  <script src="recorder.js"></script>
</body>
</html>
